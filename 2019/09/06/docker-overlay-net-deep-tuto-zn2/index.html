<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rennesong.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Introduction In part 1 of this blog post we have seen how Docker creates a dedicated namespace for the overlay and connect the containers to this namespace. We have also seen that the overlay communic">
<meta property="og:type" content="article">
<meta property="og:title" content="深入了解 Docker overlay 网络机制2">
<meta property="og:url" content="http://rennesong.com/2019/09/06/docker-overlay-net-deep-tuto-zn2/index.html">
<meta property="og:site_name" content="Rennesong&#39;s blog">
<meta property="og:description" content="Introduction In part 1 of this blog post we have seen how Docker creates a dedicated namespace for the overlay and connect the containers to this namespace. We have also seen that the overlay communic">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://rennesong.com/2019/09/06/docker-overlay-net-deep-tuto-zn2/vxlan-frame-layout.png">
<meta property="og:image" content="http://rennesong.com/2019/09/06/docker-overlay-net-deep-tuto-zn2/connectivity-vxlanpacket.png">
<meta property="og:image" content="http://rennesong.com/2019/09/06/docker-overlay-net-deep-tuto-zn2/connectivity-with-arp-fdb.png">
<meta property="og:image" content="http://rennesong.com/2019/09/06/docker-overlay-net-deep-tuto-zn2/consul-with-network.png">
<meta property="og:image" content="http://rennesong.com/2019/09/06/docker-overlay-net-deep-tuto-zn2/connectivity-complete.png">
<meta property="og:image" content="http://rennesong.com/2019/09/06/docker-overlay-net-deep-tuto-zn2/vxlan-point-to-point.png">
<meta property="og:image" content="http://rennesong.com/2019/09/06/docker-overlay-net-deep-tuto-zn2/vxlan-multicast.png">
<meta property="article:published_time" content="2019-09-06T10:12:58.000Z">
<meta property="article:modified_time" content="2019-09-06T16:37:58.000Z">
<meta property="article:author" content="rennsong">
<meta property="article:tag" content="docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://rennesong.com/2019/09/06/docker-overlay-net-deep-tuto-zn2/vxlan-frame-layout.png">

<link rel="canonical" href="http://rennesong.com/2019/09/06/docker-overlay-net-deep-tuto-zn2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>深入了解 Docker overlay 网络机制2 | Rennesong's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Rennesong's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Blog my life from now on!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rennesong.com/2019/09/06/docker-overlay-net-deep-tuto-zn2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rennsong">
      <meta itemprop="description" content="Personal blog site, to note technique and life related articles">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rennesong's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入了解 Docker overlay 网络机制2
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-06 18:12:58" itemprop="dateCreated datePublished" datetime="2019-09-06T18:12:58+08:00">2019-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-07 00:37:58" itemprop="dateModified" datetime="2019-09-07T00:37:58+08:00">2019-09-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="introduction">Introduction</h1>
<p>In part 1 of this blog post we have seen how Docker creates a dedicated namespace for the overlay and connect the containers to this namespace. We have also seen that the overlay communication between Docker hosts uses VXLAN. In this second post, we will look at VXLAN in more details and how Docker uses it.</p>
<h1 id="what-is-vxlan">What is VXLAN ?</h1>
<p>From wikipedia:</p>
<blockquote>
<p>Virtual Extensible LAN (VXLAN) is a network virtualization technology that attempts to improve the scalability problems associated with large cloud computing deployments.</p>
</blockquote>
<p>VXLAN is a tunneling technology which encapsulates L2 frames inside UDP packets usually sent on port 4789. It was originally developed by VMware, Arista and Cisco. The main goal of VXLAN was to simplify cloud deployments which require multi-tenancy at the L2 layer. It provides:</p>
<ul>
<li>Tunneling L2 over L3 to avoid the necessity of L2 connectivity between all hosts in the cluster</li>
<li>More than 4096 isolated networks (VLAN IDs are limited to 4096)</li>
</ul>
<p>On Linux, Openvswitch supports VXLAN and the kernel has native support for it since version 3.7. In addition, VXLAN works with network namespaces since kernel 3.16.</p>
<p>Here is what a VXLAN packet looks like: <img src="vxlan-frame-layout.png" alt="VxLAN 数据包结构图" /><span class="image-caption">VxLAN 数据包结构图</span></p>
<p>The <code>outer</code> IP packet is used for communication between hosts and the original L2 frame is encapuslated in a UDP packet with an additional VXLAN header for metadata (in particular the VXLAN ID).</p>
<p>We can verify that traffic between our hosts is using VXLAN with tcpdump. Let’s ping C0 from a container on docker1 and capture traffic on <code>docker0</code>: <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker1</span>:~$ docker run -it --rm --net demonet debian ping <span class="number">192.168.0.100</span></span><br><span class="line"><span class="attribute">PING</span> <span class="number">192.168.0.100</span> (<span class="number">192.168.0.100</span>): <span class="number">56</span> data bytes</span><br><span class="line"><span class="attribute">64</span> bytes from <span class="number">192.168.0.100</span>: icmp_seq=<span class="number">0</span> ttl=<span class="number">64</span> time=<span class="number">0</span>.<span class="number">680</span> ms</span><br><span class="line"><span class="attribute">64</span> bytes from <span class="number">192.168.0.100</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">64</span> time=<span class="number">0</span>.<span class="number">503</span> ms</span><br><span class="line"></span><br><span class="line"><span class="attribute">docker0</span>:~$ sudo tcpdump -pni eth<span class="number">0</span> <span class="string">&quot;port 4789&quot;</span></span><br><span class="line"><span class="attribute">tcpdump</span>: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line"><span class="attribute">listening</span> <span class="literal">on</span> eth<span class="number">0</span>, link-type EN<span class="number">10</span>MB (Ethernet), capture size <span class="number">262144</span> bytes</span><br><span class="line"><span class="attribute">12</span>:<span class="number">55</span>:<span class="number">53</span>.<span class="number">652322</span> IP <span class="number">10.0.0.11</span>.<span class="number">64667</span> &gt; <span class="number">10.0.0.10</span>.<span class="number">4789</span>: VXLAN, flags<span class="meta"> [I] (0x08), vni 256</span></span><br><span class="line"><span class="meta">IP 192.168.0.2 &gt; 192.168.0.100: ICMP echo request, id 1, seq 0, length 64</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">12:55:53.652409 IP 10.0.0.10.47697 &gt; 10.0.0.11.4789: VXLAN, flags [I] (0x08), vni 256</span></span><br><span class="line"><span class="meta">IP 192.168.0.100 &gt; 192.168.0.2: ICMP echo reply, id 1, seq 0, length 64</span></span><br></pre></td></tr></table></figure></p>
<p>Each packet generates two lines of output in tcpdump because due to VXLAN frames analysis (a few fields have been removed for readability):</p>
<ul>
<li>the <code>outer</code> frame, with IP <code>10.0.0.11</code> and <code>10.0.0.10</code> (docker hosts)</li>
<li>the <code>inner</code> frame, with IP <code>192.168.0.100</code> and <code>192.168.0.2</code> (our containers) and an ICMP payload. We can also see the MAC addresses of our containers. <img src="connectivity-vxlanpacket.png" alt="Docker overlay 网络连接示意图" /><span class="image-caption">Docker overlay 网络连接示意图</span></li>
</ul>
<h1 id="resolving-container-names-and-location">Resolving container names and location</h1>
<p>We have seen that we can ping containers on docker0 from containers on docker1 using VXLAN but we do not know yet how containers on each host can map IP addresses to MAC addresses and how the L2 frames are forwarded to the appropriate host.</p>
<p>Let’s create a container on docker1 and look at its ARP table: <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker1:~$ docker <span class="built_in">run</span> -<span class="keyword">it</span> <span class="comment">--rm --net demonet debian bash</span></span><br><span class="line">root@<span class="number">6234</span>b23677b9:/<span class="comment"># ip neighbor show</span></span><br></pre></td></tr></table></figure></p>
<p>There is no ARP information inside the container. If we ping C0 the container will generate ARP traffic. Let’s first see how this traffic is seen in the overlay namespace on docker0: <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker0:</span>~<span class="variable">$ </span>sudo nsenter --net=<span class="variable">$overns</span> tcpdump -pni any <span class="string">&quot;arp&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>Going back to our container, we will try to ping C0, which will generate an ARP packet: <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">root</span>@<span class="number">6234</span>b<span class="number">23677</span>b<span class="number">9</span>:/# ping <span class="number">192.168.0.100</span></span><br></pre></td></tr></table></figure> There is nothing in tcpdump on docker0 so the ARP traffic is not sent in the VXLAN tunnel (you may see ARP requests but no for host 192.168.0.100). Let’s recreate a container on docker1 and tcpdump in the overlay namespace of docker1 to verify that we are getting ARP queries. <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker1:~$ docker <span class="built_in">run</span> -<span class="keyword">it</span> <span class="comment">--rm --net demonet debian bash</span></span><br></pre></td></tr></table></figure> Let’s run tcpdump in another window. We list the Docker network namespaces to identify the namespace associated with the overlay. This namespace may change because the overlay namespace is deleted when there are no container attached to the network. <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker1:~$ sudo ls -<span class="number">1</span> <span class="regexp">/var/</span>run<span class="regexp">/docker/</span>netns</span><br><span class="line"><span class="number">102022</span>d57fab</span><br><span class="line">x-<span class="number">13</span>fb802253</span><br><span class="line">docker1:~$ overns=<span class="regexp">/var/</span>run<span class="regexp">/docker/</span>netns/x-<span class="number">13</span>fb802253</span><br><span class="line">docker1:~$ sudo nsenter --net=<span class="variable">$overns</span> tcpdump -peni any <span class="string">&quot;arp&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>When we ping from the window with the container, here is what we see in tcpdump: <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">19</span>:<span class="number">16</span>:<span class="number">40</span>.<span class="number">658369</span> Out <span class="number">02</span>:<span class="number">42</span>:c<span class="number">0</span>:a<span class="number">8</span>:<span class="number">00</span>:<span class="number">02</span> ethertype ARP (<span class="number">0</span>x<span class="number">0806</span>), length <span class="number">44</span>: Request who-has <span class="number">192.168.0.100</span> tell <span class="number">192.168.0.2</span>, length <span class="number">28</span></span><br><span class="line"><span class="attribute">19</span>:<span class="number">16</span>:<span class="number">40</span>.<span class="number">658352</span>   B <span class="number">02</span>:<span class="number">42</span>:c<span class="number">0</span>:a<span class="number">8</span>:<span class="number">00</span>:<span class="number">02</span> ethertype ARP (<span class="number">0</span>x<span class="number">0806</span>), length <span class="number">44</span>: Request who-has <span class="number">192.168.0.100</span> tell <span class="number">192.168.0.2</span>, length <span class="number">28</span></span><br><span class="line"><span class="attribute">19</span>:<span class="number">16</span>:<span class="number">40</span>.<span class="number">658371</span>  In <span class="number">02</span>:<span class="number">42</span>:c<span class="number">0</span>:a<span class="number">8</span>:<span class="number">00</span>:<span class="number">64</span> ethertype ARP (<span class="number">0</span>x<span class="number">0806</span>), length <span class="number">44</span>: Reply <span class="number">192.168.0.100</span> is-at <span class="number">02</span>:<span class="number">42</span>:c<span class="number">0</span>:a<span class="number">8</span>:<span class="number">00</span>:<span class="number">64</span>, length <span class="number">28</span></span><br><span class="line"><span class="attribute">19</span>:<span class="number">16</span>:<span class="number">40</span>.<span class="number">658377</span> Out <span class="number">02</span>:<span class="number">42</span>:c<span class="number">0</span>:a<span class="number">8</span>:<span class="number">00</span>:<span class="number">64</span> ethertype ARP (<span class="number">0</span>x<span class="number">0806</span>), length <span class="number">44</span>: Reply <span class="number">192.168.0.100</span> is-at <span class="number">02</span>:<span class="number">42</span>:c<span class="number">0</span>:a<span class="number">8</span>:<span class="number">00</span>:<span class="number">64</span>, length <span class="number">28</span></span><br></pre></td></tr></table></figure></p>
<p>We can see the ARP query and answer, which means the overlay namespace has the information and that it acts as an ARP proxy. We can easily verify this: <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker1</span>:~$ sudo nsenter --net=$overns ip neigh show</span><br><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">100</span> dev vxlan<span class="number">0</span> lladdr <span class="number">02</span>:<span class="number">42</span>:c<span class="number">0</span>:a<span class="number">8</span>:<span class="number">00</span>:<span class="number">64</span> PERMANENT</span><br></pre></td></tr></table></figure></p>
<p>The entry is flagged as PERMANENT which means it is static and was “manually” added and not the result of an ARP discovery. What happens if we create a second container on docker0? <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker0</span>:~$ docker run -d --ip <span class="number">192.168.0.200</span> --net demonet --name C<span class="number">1</span> debian sleep <span class="number">3600</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">docker1</span>:~$ sudo nsenter --net=$overns ip neigh show</span><br><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">200</span> dev vxlan<span class="number">0</span> lladdr <span class="number">02</span>:<span class="number">42</span>:c<span class="number">0</span>:a<span class="number">8</span>:<span class="number">00</span>:c<span class="number">8</span> PERMANENT</span><br><span class="line"><span class="attribute">192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">100</span> dev vxlan<span class="number">0</span> lladdr <span class="number">02</span>:<span class="number">42</span>:c<span class="number">0</span>:a<span class="number">8</span>:<span class="number">00</span>:<span class="number">64</span> PERMANENT</span><br></pre></td></tr></table></figure> The entry has been added automatically, even if no traffic was sent to this new container yet. This means that Docker is automatically populating the ARP entries in the overlay namespace and that the vxlan interface is acting as a proxy to answer ARP queries.</p>
<p>If we look at the configuration of the vxlan interface, we can see that it has the proxy flag set which explains this behavior (we will look at the other options later). <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker1</span>:~$ sudo nsenter --net=$overns ip -d link show vxlan<span class="number">0</span></span><br><span class="line"><span class="attribute">xx</span>: vxlan<span class="number">0</span>: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="number">1450</span> qdisc noqueue master br<span class="number">0</span> state UNKNOWN mode DEFAULT group default</span><br><span class="line">    <span class="attribute">link</span>/ether <span class="number">5</span>a:<span class="number">71</span>:<span class="number">8</span>f:a<span class="number">4</span>:b<span class="number">8</span>:<span class="number">1</span>b brd ff:ff:ff:ff:ff:ff promiscuity <span class="number">1</span></span><br><span class="line">    <span class="attribute">vxlan</span> id <span class="number">256</span> srcport <span class="number">10240</span> <span class="number">65535</span> dstport <span class="number">4789</span> proxy l<span class="number">2</span>miss l<span class="number">3</span>miss ageing <span class="number">300</span></span><br><span class="line">    <span class="attribute">bridge_slav</span></span><br></pre></td></tr></table></figure></p>
<p>What about the location of the MAC address (on which host is 02:42:c0:a8:00:64)? We can look at the bridge forwarding database in the overlay namespace: <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker1</span>:~$ sudo nsenter --net=$overns bridge fdb show</span><br><span class="line"><span class="attribute">5a</span>:<span class="number">71</span>:<span class="number">8</span>f:a<span class="number">4</span>:b<span class="number">8</span>:<span class="number">1</span>b dev vxlan<span class="number">0</span> vlan <span class="number">0</span> master br<span class="number">0</span> permanent</span><br><span class="line"><span class="attribute">9a</span>:ad:<span class="number">35</span>:<span class="number">64</span>:<span class="number">39</span>:<span class="number">39</span> dev veth<span class="number">2</span> vlan <span class="number">0</span> master br<span class="number">0</span> permanent</span><br><span class="line"><span class="attribute">02</span>:<span class="number">42</span>:c<span class="number">0</span>:a<span class="number">8</span>:<span class="number">00</span>:c<span class="number">8</span> dev vxlan<span class="number">0</span> dst <span class="number">10.0.0.10</span> self permanent</span><br><span class="line"><span class="attribute">02</span>:<span class="number">42</span>:c<span class="number">0</span>:a<span class="number">8</span>:<span class="number">00</span>:<span class="number">64</span> dev vxlan<span class="number">0</span> dst <span class="number">10.0.0.10</span> self permanent</span><br><span class="line"><span class="attribute">33</span>:<span class="number">33</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> dev veth<span class="number">2</span> self permanent</span><br><span class="line"><span class="attribute">01</span>:<span class="number">00</span>:<span class="number">5</span>e:<span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> dev veth<span class="number">2</span> self permanent</span><br></pre></td></tr></table></figure></p>
<p>We can see that the MAC addresses for our two containers on docker0 are in the database with a permanent flag. This information is also dynamically populated by Docker. <img src="connectivity-with-arp-fdb.png" alt="Docker overlay 网络连接示意图" /><span class="image-caption">Docker overlay 网络连接示意图</span></p>
<h1 id="distribution-of-macfdb-information">Distribution of MAC/FDB information</h1>
<p>We have just discovered that Docker populates MAC and FDB information automatically. How is this done?</p>
<p>We can first look at the content of Consul. What is stored in there? <img src="consul-with-network.png" alt="Docker overlay 网络连接示意图" /><span class="image-caption">Docker overlay 网络连接示意图</span></p>
<p>The network that was empty when we started now contains information and we can recognize the id of our overlay: <code>13fb802253b6f0a44e17e2b65505490e0c80527e1d78c4f5c74375aff4bf882a</code>.</p>
<p>The Consul UI does not display keys when they are too long but we can use curl to look at the content (Docker stores the information as JSON which is based64 encoded and Consul answers queries in JSON): <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">net<span class="operator">=</span>$(docker network inspect demonet <span class="operator">-</span>f &#123;&#123;.<span class="type">Id</span>&#125;&#125;)</span><br><span class="line">curl <span class="operator">-</span>s http:<span class="comment">//consul:8500/v1/kv/docker/network/v1.0/network/$&#123;net&#125;/ | jq  -r &quot;.[0].Value&quot;  |  base64 -d | jq .</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;addrSpace&quot;</span>: <span class="string">&quot;GlobalDefault&quot;</span>,</span><br><span class="line">  <span class="string">&quot;attachable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;created&quot;</span>: <span class="string">&quot;2017-04-23T16:33:02.442759329Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;enableIPv6&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;generic&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;com.docker.network.enable_ipv6&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;com.docker.network.generic&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;id&quot;</span>: <span class="string">&quot;13fb802253b6f0a44e17e2b65505490e0c80527e1d78c4f5c74375aff4bf882a&quot;</span>,</span><br><span class="line">  <span class="string">&quot;inDelete&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;ingress&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;internal&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;ipamOptions&quot;</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">&quot;ipamType&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">  <span class="string">&quot;ipamV4Config&quot;</span>: <span class="string">&quot;[&#123;<span class="subst">\&quot;</span>PreferredPool<span class="subst">\&quot;</span>:<span class="subst">\&quot;</span>192.168.0.0/24<span class="subst">\&quot;</span>,<span class="subst">\&quot;</span>SubPool<span class="subst">\&quot;</span>:<span class="subst">\&quot;</span><span class="subst">\&quot;</span>,<span class="subst">\&quot;</span>Gateway<span class="subst">\&quot;</span>:<span class="subst">\&quot;</span><span class="subst">\&quot;</span>,<span class="subst">\&quot;</span>AuxAddresses<span class="subst">\&quot;</span>:null&#125;]&quot;</span>,</span><br><span class="line">  <span class="string">&quot;ipamV4Info&quot;</span>: <span class="string">&quot;[&#123;<span class="subst">\&quot;</span>IPAMData<span class="subst">\&quot;</span>:<span class="subst">\&quot;</span>&#123;<span class="subst">\\</span><span class="subst">\&quot;</span>AddressSpace<span class="subst">\\</span><span class="subst">\&quot;</span>:<span class="subst">\\</span><span class="subst">\&quot;</span>GlobalDefault<span class="subst">\\</span><span class="subst">\&quot;</span>,<span class="subst">\\</span><span class="subst">\&quot;</span>Gateway<span class="subst">\\</span><span class="subst">\&quot;</span>:<span class="subst">\\</span><span class="subst">\&quot;</span>192.168.0.1/24<span class="subst">\\</span><span class="subst">\&quot;</span>,<span class="subst">\\</span><span class="subst">\&quot;</span>Pool<span class="subst">\\</span><span class="subst">\&quot;</span>:<span class="subst">\\</span><span class="subst">\&quot;</span>192.168.0.0/24<span class="subst">\\</span><span class="subst">\&quot;</span>&#125;<span class="subst">\&quot;</span>,<span class="subst">\&quot;</span>PoolID<span class="subst">\&quot;</span>:<span class="subst">\&quot;</span>GlobalDefault/192.168.0.0/24<span class="subst">\&quot;</span>&#125;]&quot;</span>,</span><br><span class="line">  <span class="string">&quot;labels&quot;</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;demonet&quot;</span>,</span><br><span class="line">  <span class="string">&quot;networkType&quot;</span>: <span class="string">&quot;overlay&quot;</span>,</span><br><span class="line">  <span class="string">&quot;persist&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;postIPv6&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;scope&quot;</span>: <span class="string">&quot;global&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> We can find all the metadata on our network:</p>
<ul>
<li>name: demonet</li>
<li>id: 13fb802253b6f0a44e17e2b65505490e0c80527e1d78c4f5c74375aff4bf882a</li>
<li>subnet range: 192.168.0.0/24</li>
</ul>
<p>We can also retrieve information about endpoints but the curl queries are hard to read so we will use this small python script (available on the GitHub repository) to retrieve this information: <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import consul</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line"><span class="comment"># First we connect to consul</span></span><br><span class="line"><span class="attribute">c</span>=consul.Consul(host=&quot;consul&quot;,port=8500)</span><br><span class="line"></span><br><span class="line"><span class="comment"># We retrieve all endpoint keys from Consul</span></span><br><span class="line">(idx,endpoints)=c.kv.<span class="builtin-name">get</span>(<span class="string">&quot;docker/network/v1.0/endpoint/&quot;</span>,<span class="attribute">recurse</span>=<span class="literal">True</span>)</span><br><span class="line">epdata=[ ep[<span class="string">&#x27;Value&#x27;</span>] <span class="keyword">for</span> ep <span class="keyword">in</span> endpoints <span class="keyword">if</span> ep[<span class="string">&#x27;Value&#x27;</span>] is <span class="keyword">not</span> None]</span><br><span class="line"></span><br><span class="line"><span class="comment"># We print some interesting data on these endpoints</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> epdata:</span><br><span class="line">    <span class="attribute">jsondata</span>=json.loads(data.decode(&quot;utf-8&quot;))</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">&quot;Endpoint Name: %s&quot;</span> % jsondata[<span class="string">&quot;name&quot;</span>])</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">&quot;IP address: %s&quot;</span> % jsondata[<span class="string">&quot;ep_iface&quot;</span>][<span class="string">&quot;addr&quot;</span>])</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">&quot;MAC address: %s&quot;</span> % jsondata[<span class="string">&quot;ep_iface&quot;</span>][<span class="string">&quot;mac&quot;</span>])</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">&quot;Locator: %s\n&quot;</span> % jsondata[<span class="string">&quot;locator&quot;</span>])</span><br></pre></td></tr></table></figure></p>
<p>The script displays the main pieces of information on the container endpoints:</p>
<ul>
<li>Name</li>
<li>IP address</li>
<li>MAC address</li>
<li>Locator: the host where the container is located</li>
</ul>
<p>Here is what we find out about our setup: <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker1</span>:~$ python/dump_endpoints.py</span><br><span class="line"><span class="attribute">Endpoint</span> Name: adoring_einstein</span><br><span class="line"><span class="attribute">IP</span> address: <span class="number">192.168.0.2</span>/<span class="number">24</span></span><br><span class="line"><span class="attribute">MAC</span> address: <span class="number">02</span>:<span class="number">42</span>:c<span class="number">0</span>:a<span class="number">8</span>:<span class="number">00</span>:<span class="number">02</span></span><br><span class="line"><span class="attribute">Locator</span>: <span class="number">10.0.0.11</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">Endpoint</span> Name: C<span class="number">1</span></span><br><span class="line"><span class="attribute">IP</span> address: <span class="number">192.168.0.200</span>/<span class="number">24</span></span><br><span class="line"><span class="attribute">MAC</span> address: <span class="number">02</span>:<span class="number">42</span>:c<span class="number">0</span>:a<span class="number">8</span>:<span class="number">00</span>:c<span class="number">8</span></span><br><span class="line"><span class="attribute">Locator</span>: <span class="number">10.0.0.10</span></span><br></pre></td></tr></table></figure></p>
<p>Consul is used as a reference store for all static information. However, it is not enough to dynamically notify all hosts when a container is created. It turns out that Docker uses Serf and its Gossip protocol to achieve this. We can easily verify this by subscribing to serf events on docker0 and create a container on docker1: <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ serf agent -bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">17946</span> -join <span class="number">10.0</span><span class="number">.0</span><span class="number">.11</span>:<span class="number">7946</span> -node demo -log-level=debug -event-handler=./serf.sh</span><br><span class="line">#########################################</span><br><span class="line">New event: member-join</span><br><span class="line">demo    <span class="number">10.0</span><span class="number">.0</span><span class="number">.10</span></span><br><span class="line">docker0 <span class="number">10.0</span><span class="number">.0</span><span class="number">.10</span></span><br><span class="line">docker1 <span class="number">10.0</span><span class="number">.0</span><span class="number">.11</span></span><br><span class="line">#########################################</span><br></pre></td></tr></table></figure></p>
<p>I removed most of the output to focus on relevant information: we can see all the nodes participating in Gossip.</p>
<p>Serf is started with the following options:</p>
<ul>
<li>bind: to bind a port different from 7946 (already used by Docker)</li>
<li>join: to join the serf cluster</li>
<li>node: to give an alternate name to the node (docker0 is already taken)</li>
<li>event-handler: a simple script to display serf events</li>
<li>log-level=debug: required to see the output of the event handler script</li>
</ul>
<p>The serf.sh script has the following content: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;New event: <span class="variable">$&#123;SERF_EVENT&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">&quot;<span class="variable">$&#123;line&#125;</span>\n&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>Let’s now create a container on docker1 and look at the ouput on docker0: <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker1:~$ docker <span class="keyword">run</span> -it --<span class="keyword">rm</span> --<span class="keyword">net</span> demonet debian <span class="keyword">sleep</span> 10</span><br></pre></td></tr></table></figure></p>
<p>On docker0 we see: <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">New</span> event: user</span><br><span class="line"><span class="attribute">join</span> <span class="number">192.168.0.2</span> <span class="number">255.255.255.0</span> <span class="number">02</span>:<span class="number">42</span>:c<span class="number">0</span>:a<span class="number">8</span>:<span class="number">00</span>:<span class="number">02</span></span><br></pre></td></tr></table></figure></p>
<p>Then after 10s when the container exits on docker1: <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">New</span> event: user</span><br><span class="line"><span class="attribute">leave</span> <span class="number">192.168.0.2</span> <span class="number">255.255.255.0</span> <span class="number">02</span>:<span class="number">42</span>:c<span class="number">0</span>:a<span class="number">8</span>:<span class="number">00</span>:<span class="number">02</span></span><br></pre></td></tr></table></figure></p>
<p>The Docker daemon subscribes to these events to create and remove entries in the ARP and FDB tables. <img src="connectivity-complete.png" alt="Docker overlay 网络连接示意图" /><span class="image-caption">Docker overlay 网络连接示意图</span></p>
<p>In Swarm mode, Docker does not rely on Serf to synchronize information between nodes but relies on its own implementation of the Gossip protocol. It achieves exactly the same thing.</p>
<h1 id="alternate-vxlan-resolution-options">Alternate VXLAN resolution options</h1>
<p>The Docker daemon automatically populates ARP and FDB tables based on information received through the Gossip protocol via Serf, and relies on ARP proxying by the VLXAN interface. However, VXLAN also gives us other options for discovery.</p>
<h2 id="point-to-point-resolution">Point-to-point resolution</h2>
<p>When VXLAN is configured with the “remote » option, it sends all unknown traffic to this IP. This setup is very simple but limited to tunnels between two hosts. <img src="vxlan-point-to-point.png" alt="Docker overlay 网络连接示意图" /><span class="image-caption">Docker overlay 网络连接示意图</span></p>
<h2 id="multicast-resolution">Multicast resolution</h2>
<p>When VXLAN is configured with the “group » option, it sends all unknown traffic to this multicast group. This setup is very efficient but requires multicast connectivity between all hosts, which is not always possible in particular when using public cloud. <img src="vxlan-multicast.png" alt="Docker overlay 网络连接示意图" /><span class="image-caption">Docker overlay 网络连接示意图</span></p>
<p>For more detailed information on VXLAN configuration on Linux, I recommand this very complete post: VXLAN &amp; Linux.</p>
<h1 id="conclusion">Conclusion</h1>
<p>In the first two parts of this post, we have seen how the Docker overlay works and the technologies it relies on. In the third and final part, we will see how we can build our own overlay from scratch using only Linux commands.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/docker/" rel="tag"># docker</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/09/06/docker-overlay-net-deep-tuto-zn1/" rel="prev" title="深入了解 Docker overlay 网络机制1">
      <i class="fa fa-chevron-left"></i> 深入了解 Docker overlay 网络机制1
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/09/06/docker-overlay-net-deep-tuto-zn3/" rel="next" title="深入了解 Docker overlay 网络机制3">
      深入了解 Docker overlay 网络机制3 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#what-is-vxlan"><span class="nav-number">2.</span> <span class="nav-text">What is VXLAN ?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#resolving-container-names-and-location"><span class="nav-number">3.</span> <span class="nav-text">Resolving container names and location</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#distribution-of-macfdb-information"><span class="nav-number">4.</span> <span class="nav-text">Distribution of MAC&#x2F;FDB information</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#alternate-vxlan-resolution-options"><span class="nav-number">5.</span> <span class="nav-text">Alternate VXLAN resolution options</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#point-to-point-resolution"><span class="nav-number">5.1.</span> <span class="nav-text">Point-to-point resolution</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#multicast-resolution"><span class="nav-number">5.2.</span> <span class="nav-text">Multicast resolution</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#conclusion"><span class="nav-number">6.</span> <span class="nav-text">Conclusion</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rennsong</p>
  <div class="site-description" itemprop="description">Personal blog site, to note technique and life related articles</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">77</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rennsong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




  















  

  

</body>
</html>
