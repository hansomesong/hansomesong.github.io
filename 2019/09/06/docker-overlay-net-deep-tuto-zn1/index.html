<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rennesong.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="译者按： Laurent BERNAILLE 在他们公司的博客上写了三篇关于 Docker overlay network 工作机制的文章。本文因为有很高的专业度，所以一些英语表达，如 network overlay, linux network namespace, VxLAN 等并不翻译。 点击此处阅读原文 Laurent BERNAILLE, 现任 Cloud Native Services">
<meta property="og:type" content="article">
<meta property="og:title" content="深入了解 Docker overlay 网络机制1">
<meta property="og:url" content="http://rennesong.com/2019/09/06/docker-overlay-net-deep-tuto-zn1/index.html">
<meta property="og:site_name" content="Rennesong&#39;s blog">
<meta property="og:description" content="译者按： Laurent BERNAILLE 在他们公司的博客上写了三篇关于 Docker overlay network 工作机制的文章。本文因为有很高的专业度，所以一些英语表达，如 network overlay, linux network namespace, VxLAN 等并不翻译。 点击此处阅读原文 Laurent BERNAILLE, 现任 Cloud Native Services">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://rennesong.com/.com//servers-network-topo.png">
<meta property="og:image" content="http://rennesong.com/.com//consul-start.png">
<meta property="og:image" content="http://rennesong.com/.com//overlay-net-topo-stage1.png">
<meta property="og:image" content="http://rennesong.com/.com//overlay-net-topo-stage2.png">
<meta property="og:image" content="http://rennesong.com/.com//overlay-net-topo-stage3.png">
<meta property="og:image" content="http://rennesong.com/.com//overlay-net-topo-stage4.png">
<meta property="article:published_time" content="2019-09-06T02:58:26.000Z">
<meta property="article:modified_time" content="2019-09-06T16:11:47.641Z">
<meta property="article:author" content="rennsong">
<meta property="article:tag" content="docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://rennesong.com/.com//servers-network-topo.png">

<link rel="canonical" href="http://rennesong.com/2019/09/06/docker-overlay-net-deep-tuto-zn1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>深入了解 Docker overlay 网络机制1 | Rennesong's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Rennesong's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Blog my life from now on!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://rennesong.com/2019/09/06/docker-overlay-net-deep-tuto-zn1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rennsong">
      <meta itemprop="description" content="Personal blog site, to note technique and life related articles">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rennesong's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入了解 Docker overlay 网络机制1
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-06 10:58:26" itemprop="dateCreated datePublished" datetime="2019-09-06T10:58:26+08:00">2019-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-07 00:11:47" itemprop="dateModified" datetime="2019-09-07T00:11:47+08:00">2019-09-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>译者按： Laurent BERNAILLE 在他们公司的博客上写了三篇关于 Docker overlay network 工作机制的文章。本文因为有很高的专业度，所以一些英语表达，如 network overlay, linux network namespace, VxLAN 等并不翻译。</p>
<p><a href="https://blog.d2si.io/2017/04/25/deep-dive-into-docker-overlay-networks-part-1/" target="_blank" rel="noopener">点击此处阅读原文</a> Laurent BERNAILLE, 现任 Cloud Native Services CTO, Laurent est en perpétuelle réflexion sur les alternatives offertes par le Cloud Public. Laurent 帮助他的客户采用最新的 best pratiques 以及最信的技术，帮助客户们更快对市场做出反应。 Il oriente ses clients vers une adoption en continu des meilleurs pratiques et des dernières technologies pour qu'ils gagnent en vélocité.</p>
<h1 id="介绍">介绍</h1>
<p>在 D2SI(译者注：一家法国云服务创业公司), 我们自 Docker 诞生之初就一直在使用这个技术，并且一直在帮助众多项目迈入生产阶段。我们相信，使得一个项目步入生产阶段要求对项目使用的技术有很深入的理解，这样才有可能解决生产阶段中遇到的各种复杂的问题，分析遇到的异常行为抑或是解决性能下降。这就是为什么我们试着尽可能深入地去理解 Docker 使用的每个技术模块。</p>
<p>本文关注的问题是: Docker network overlay. Docker network overlay 驱动依赖以下技术：network namespace, VxLAN, Netlink 以及分布式键值存储系统(a distributed key-value store)。本文将逐一介绍上述机制以及他们对应的命令行工具。本来还将通过具体的操作展示， 当创建docker network overlay 以连接容器实例的时候，这些机制是如何彼此交互的。</p>
<p>本博文来源于我在在美国奥斯汀的 <a href="http://2017.dockercon.com/" target="_blank" rel="noopener">DockerCon2017</a> 上做的报告。演示文稿可以通过<a href="https://www.slideshare.net/lbernail/deep-dive-in-docker-overlay-networks" target="_blank" rel="noopener">点击链接</a>下载。本系列博文使用的所有代码均可通过<a href="https://github.com/lbernail/dockercon2017" target="_blank" rel="noopener">github</a>下载。</p>
<h1 id="docker-overlay-networks">Docker Overlay Networks</h1>
<p>首先，我们想在3台 Docker主机之间构建一个 overlay network，其中两台运行 Docker, 另外一台运行 Consul。本例中，Docker 使用 Consul 存储 overlay networks 相关的，需要在各个Docker主机之间共享的元数据, 例如，容器的IP地址，MAC地址以及位置(位于哪台Docker主机上)。在早于 Docker 1.12 版本, Docker 需要使用外置键值存储系统，如 Etcd or Consul，来创建 overlay network 以及 Docker Swarms (如今，这种方式创建的 Docker swarms 通过被称为 “古典 Swarm”)。从 Docker 1.12版本之后, Docker 可以采用内置的键值存储系统来创建 Docker 集群以及 overlay networks (“Swarm 模式” 或者 “新 swarm”)。本文中，我们选用 Consul，因为该技术允许我们查看由 Docker 存入的键值，让我们更好地理解键值存储系统的作用。我们让 Consule 运行在一个单节点上。在实际中，我们一般会用至少包含3个节点的集群，以保证可靠性。</p>
<p>在本文的示例中, 我们用的主机采用IP地址如下:</p>
<ul>
<li>consul: 10.0.0.5</li>
<li>docker0: 10.0.0.10</li>
<li>docker1: 10.0.0.0.11</li>
</ul>
<figure>
<img src="/.com//servers-network-topo.png" alt="基本网络拓扑结构示意图"><span class="image-caption">基本网络拓扑结构示意图</span><figcaption>基本网络拓扑结构示意图</figcaption>
</figure>
<h1 id="启动-consul-与-docker-服务">启动 Consul 与 Docker 服务</h1>
<p>首先我们需要启动 Consul 服务器。我们只需要从网上下载Consul。我们只需要通过下面的命令行开启一个最简约的 Consul 服务。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ consul agent -server -dev -ui -client 0.0.0.0</span><br></pre></td></tr></table></figure> 用到的参数解释如下：</p>
<ul>
<li>server: 以服务器模式启动 consul agent</li>
<li>dev: 创建一个没有任务持久化存储的单独的 Consul 服务器</li>
<li>ui: 开启 WEB 页面，以便查看由 Docker 创建的键值对</li>
<li>client 0.0.0.0: 为客户的访问绑定所有的网络接口。默认是只绑定<code>127.0.0.1</code></li>
</ul>
<p>为了配置 Docker 引擎使用 Consul 作为键值存储系统，需要启动 docker 守护进程，并且指定<code>cluster-store</code>选项: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dockerd -H fd:&#x2F;&#x2F; --cluster-store&#x3D;consul:&#x2F;&#x2F;consul:8500 --cluster-advertise&#x3D;eth0:2376</span><br></pre></td></tr></table></figure></p>
<p>可选参数 <code>cluster-advertise</code> 指定采用哪个IP地址在集群中to advertise in the cluster for a docker host (这个可选参数并不是可有可无). 上述命令假定<code>consul</code>可以被客户(即其他Docker主机)解析为了具体IP地址。在本例中，解析为<code>10.0.0.5</code>。</p>
<p>此时如果我们查看 Consul 图形界面，我们可以看到 Docker 确实创建一些键，但是网络键: <code>http://consul:8500/v1/kv/docker/network/v1.0/network/</code> 仍然是空的。</p>
<figure>
<img src="/.com//consul-start.png" alt="Consul启动后初始页面"><span class="image-caption">Consul启动后初始页面</span><figcaption>Consul启动后初始页面</figcaption>
</figure>
<p>你们可以很容易地在AWS平台上，通过使用terraform脚本(通过<a href="https://github.com/lbernail/dockercon2017" target="_blank" rel="noopener">Github下载</a>)来创建同样的实验环境。一切默认配置(尤其是要使用的区域)定义在<code>variables.tf</code>. 你们需要给变量<code>key_pair</code>赋值，可以通过命令行<code>terraform apply -var key_pair=demo</code>或者通过修改文件<code>variables.tf</code>。</p>
<p>这三个实例都被配置上了userdata: consul and docker 都被安装了并且通过合适的参数启动。一条记录被添加进文件<code>/etc/hosts</code>，以便 consul 可以被解析成 consul server 的IP地址。当连接到 consul or docker 服务器, 你们应该使用公共IP地址 (given in terraform outputs) and connect with user “admin” (the terraform setup uses a debian AMI).</p>
<h1 id="创建-overlay">创建 Overlay</h1>
<p>现在我们可以在两个Docker节点之间创建overlay网络: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker network create --driver overlay --subnet 192.168.0.0&#x2F;24 demonet</span><br><span class="line">13fb802253b6f0a44e17e2b65505490e0c80527e1d78c4f5c74375aff4bf882a</span><br></pre></td></tr></table></figure> 我们使用overlay驱动，选择<code>192.168.0.0/24</code>作为overlay的子网前缀 (<code>--subnet</code> 这个参数是可选的，但是我们希望配备一个显著不同于主机所在的子网前缀，让我们分析变得更简单)。</p>
<p>我们现在验证下overlay是否正确地在配置在了两台Docker节点上: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">eb096cb816c0        bridge              bridge              local</span><br><span class="line">13fb802253b6        demonet             overlay             global</span><br><span class="line">d538d58b17e7        host                host                local</span><br><span class="line">f2ee470bb968        none                null                local</span><br><span class="line"></span><br><span class="line">docker1:~$ docker network ls</span><br><span class="line">docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">eb7a05eba815        bridge              bridge              local</span><br><span class="line">13fb802253b6        demonet             overlay             global</span><br><span class="line">4346f6c422b2        host                host                local</span><br><span class="line">5e8ac997ecfa        none                null                local</span><br></pre></td></tr></table></figure> 看起来一切正常。两台Docker节点上均识别了标识为<code>demonet</code>的网络。<code>demonet</code>在两台Docker节点上有同样的ID。</p>
<p>现在我们来确认下创建的overlay网络可以正常运行。我们在节点docker0创建一个容器C0，显式地分配IP地址<code>192.168.0.100</code>, 并使之连接在overlay网络上。在另一个节点docker1上我们创建另键一个容器, 连接到同一个overlay网络中，并且使之ping下C0. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker run -d --ip 192.168.0.100 --net demonet --name C0 debian sleep 3600</span><br><span class="line"></span><br><span class="line">docker1:~$ docker run -it --rm --net demonet debian bash</span><br><span class="line">root@e37bf5e35f83:&#x2F;# ping 192.168.0.100</span><br><span class="line">PING 192.168.0.100 (192.168.0.100): 56 data bytes</span><br><span class="line">64 bytes from 192.168.0.100: icmp_seq&#x3D;0 ttl&#x3D;64 time&#x3D;0.618 ms</span><br><span class="line">64 bytes from 192.168.0.100: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.483 ms</span><br></pre></td></tr></table></figure> 关于 Docker 运行参数的一些解释:</p>
<ul>
<li>如果<code>docker run</code>后面追加<code>-d=true</code>或者<code>-d</code>，那么容器将会运行在后台模式。此时所有I/O数据只能通过网络资源或者共享卷组来进行交互。因为容器不再监听你执行<code>docker run</code>的这个终端命令行窗口。但你可以通过执行<code>docker attach</code>来重新附着到该容器的回话中。需要注意的是，容器运行在后台模式下，是不能使用<code>--rm</code>选项的。</li>
<li>如果要进行交互式操作（例如Shell脚本），那我们必须使用<code>-i -t</code>参数同容器进行数据交互。</li>
<li>默认情况下，每个容器在退出时，它的文件系统也会保存下来，这样一方面调试会方便些，因为你可以通过查看日志等方式来确定最终状态。另外一方面，你也可以保存容器所产生的数据。但是当你仅仅需要短暂的运行一个容器，并且这些数据不需要保存，你可能就希望Docker能在容器结束时自动清理其所产生的数据。这个时候你就需要<code>--rm</code>这个参数了。 注意：<code>--rm</code> 和 <code>-d</code> 不能共用！</li>
</ul>
<p>我们观察到，两个容器实例之间已经具备了连通性。如果我们试着从docker1(而不是一个容器实例)去ping容器C0, 是ping不同的，因为节点docker1并不清楚隔离在overlay中的子网<code>192.168.0.0/24</code>. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker1:~$ ping 192.168.0.100</span><br><span class="line">PING 192.168.0.100 (192.168.0.100) 56(84) bytes of data.</span><br><span class="line">^C--- 192.168.0.100 ping statistics ---</span><br><span class="line">4 packets transmitted, 0 received, 100% packet loss, time 3024ms</span><br></pre></td></tr></table></figure> Here is what we have built so far: <img src="/.com//overlay-net-topo-stage1.png"></p>
<h1 id="overlay-背后的原理">Overlay 背后的原理</h1>
<p>现在我们已经创建好了overlay网络。我们来看下docker overlay网络是如何工作的。</p>
<h2 id="容器的网络配置">容器的网络配置</h2>
<p>节点docker0上的容器C0的网络配置是怎样的？ <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker exec C0 ip addr show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default</span><br><span class="line">    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1&#x2F;8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">6: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default</span><br><span class="line">    link&#x2F;ether 02:42:c0:a8:00:64 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.0.100&#x2F;24 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">9: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link&#x2F;ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.2&#x2F;16 scope global eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure> 该容器中，除loopback接口之外，我们还有两个网络接口：</p>
<ul>
<li>eth0: 配置了一个在子网192.168.0.0/24中的IP地址. 这个接口在overlay网络中(参加上图).</li>
<li>eth1: 配置了一个在子网172.18.0.2/16中的IP地址, 我们之前从未配置过该接口。</li>
</ul>
<p>那么C0的路由配置是怎样的？ <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker exec C0 ip route show</span><br><span class="line">default via 172.18.0.1 dev eth1</span><br><span class="line">172.18.0.0&#x2F;16 dev eth1  proto kernel  scope link  src 172.18.0.2</span><br><span class="line">192.168.0.0&#x2F;24 dev eth0  proto kernel  scope link  src 192.168.0.100</span><br></pre></td></tr></table></figure> 路由配置显示，默认路由是通过设备<code>eth1</code>. 这意味着，这个接口可以被用来访问overlay网络之外的资源。这一点可以通过ping一个外部IP地址来验证。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it C0 ping 8.8.8.8</span><br><span class="line">PING 8.8.8.8 (8.8.8.8): 56 data bytes</span><br><span class="line">64 bytes from 8.8.8.8: icmp_seq&#x3D;0 ttl&#x3D;51 time&#x3D;0.957 ms</span><br><span class="line">64 bytes from 8.8.8.8: icmp_seq&#x3D;1 ttl&#x3D;51 time&#x3D;0.975 ms</span><br></pre></td></tr></table></figure></p>
<p>注意：我们也可以通过使用可选参数<code>--internal</code>创建一个overlay网络。这样该网络中的容器就无法访问外部网络。</p>
<p>我们来看看是否可以获得更多的关于这些网络接口的信息。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker exec C0 ip -details link show eth0</span><br><span class="line">6: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    link&#x2F;ether 02:42:c0:a8:00:64 brd ff:ff:ff:ff:ff:ff promiscuity 0</span><br><span class="line">    veth</span><br><span class="line"></span><br><span class="line">docker0:~$ docker exec C0 ip -details link show eth1</span><br><span class="line">9: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    link&#x2F;ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff promiscuity 0</span><br><span class="line">    veth</span><br></pre></td></tr></table></figure></p>
<p>两个网络接口的类型都是<code>veth</code>. <code>veth</code>类型的接口总是成对出现并通过一条虚拟的网线连接。这一对<code>veth</code>设备可以位于不同的network namespace，使得网络流量可以从一个namespace传递到另一个namespace. These two veth are used to get outside of the container network namespace.</p>
<p>Here is what we have found out so far:</p>
<p><img src="/.com//overlay-net-topo-stage2.png"></p>
<p>现在我们需要找出来<code>eth0</code>还有<code>eth1</code>的对等网络接口。</p>
<h2 id="what-is-the-container-connected-to">What is the container connected to?</h2>
<p>我们可以使用<code>ethtool</code>命令找到一个给定<code>veth</code>设备的另一端的对等设备。但是，<code>ethtool</code>这个命令在我们用的容器中并不可用。不过我们还是两种方式在容器中执行这个命令。第一个是用<code>nsenter</code>。<code>nsenter</code>允许我们进入一个或者多个和一个给定进程相关的命名空间。第二种方法是通过<code>ip netns exec</code>。这个命令依赖<code>iproute</code>在一个给定的network namespace执行命令。</p>
<p>Docker 不会在文件夹<code>/var/run/netns</code>中(<code>ip netns</code>查找network namespace的地方)创建符号链接。这就是为什么我们将依赖 <code>nsenter</code> (而不是<code>ip netns</code>)来查询由Docker创建的命名空间。</p>
<p>我们通过运行以下命令来列出来Docker创建的network namespace: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ sudo ls -1 &#x2F;var&#x2F;run&#x2F;docker&#x2F;netns</span><br><span class="line">e4b8ecb7ae7c</span><br><span class="line">1-13fb802253</span><br></pre></td></tr></table></figure> 为了使用这些信息，我们需要识别出容器的network namespace. 我们可以<code>inspect</code>指定容器，并且从<code>SandboxKey</code>中提取出我们需要的信息来做到。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker inspect C0 -f &#123;&#123;.NetworkSettings.SandboxKey&#125;&#125; </span><br><span class="line">&#x2F;var&#x2F;run&#x2F;docker&#x2F;netns&#x2F;e4b8ecb7ae7c</span><br><span class="line">docker0:~$ C0netns&#x3D;$(docker inspect C0 -f &#123;&#123;.NetworkSettings.SandboxKey&#125;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>我们也可以在一个容器的network namespace中执行linux命令(即使容器没有这个命令): <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ sudo nsenter --net&#x3D;$C0netns ip addr show eth0</span><br><span class="line">6: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default</span><br><span class="line">    link&#x2F;ether 02:42:c0:a8:00:64 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.0.100&#x2F;24 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure> 让我们看看和容器C0中的<code>eth0</code>还有<code>eth1</code>对等接口关联的网络接口的标识: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ sudo nsenter --net&#x3D;$C0netns ethtool -S eth0</span><br><span class="line">NIC statistics:</span><br><span class="line">    peer_ifindex: 7</span><br><span class="line">docker0:~$ sudo nsenter --net&#x3D;$C0netns ethtool -S eth1</span><br><span class="line">NIC statistics:</span><br><span class="line">    peer_ifindex: 10</span><br></pre></td></tr></table></figure></p>
<p>我们现在再看看标识为<code>7</code>还有<code>10</code>网络接口。我们先在节点docker1上先查看一番: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ ip -details link show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default</span><br><span class="line">    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity 0</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9001 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link&#x2F;ether 06:e2:c0:20:ec:9f brd ff:ff:ff:ff:ff:ff promiscuity 0</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default</span><br><span class="line">    link&#x2F;ether 02:42:a7:17:99:39 brd ff:ff:ff:ff:ff:ff promiscuity 0</span><br><span class="line">    bridge</span><br><span class="line">8: docker_gwbridge: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    link&#x2F;ether 02:42:be:d6:b0:c5 brd ff:ff:ff:ff:ff:ff promiscuity 0</span><br><span class="line">    bridge</span><br><span class="line">10: vethbc521fc: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker_gwbridge state UP mode DEFAULT group default</span><br><span class="line">    link&#x2F;ether 32:a1:47:1a:7f:1e brd ff:ff:ff:ff:ff:ff promiscuity 1</span><br><span class="line">    veth</span><br><span class="line">    bridge_slave</span><br></pre></td></tr></table></figure> 从该命令的输出来看，没有标识为<code>7</code>的接口的线索但是我们发现了标识为<code>10</code>的接口，也就是<code>eth1</code>的对等接口。另外, <code>10</code>号接口被连接在一个名为<code>docker_gwbridge</code>的网桥上。 <code>docker_gwbridge</code>网桥是个什么东东呢? 如果我们列出来由docker管理的网络，我们可以看到<code>docker_gwbridge</code>是出现在列表中的: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">eb096cb816c0        bridge              bridge              local</span><br><span class="line">13fb802253b6        demonet             overlay             global</span><br><span class="line">f6823b311fd2        docker_gwbridge     bridge              local</span><br><span class="line">d538d58b17e7        host                host                local</span><br><span class="line">f2ee470bb968        none                null                local</span><br></pre></td></tr></table></figure></p>
<p>现在我们来看网桥<code>docker_gwbridge</code>的元数据: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker inspect docker_gwbridge</span><br><span class="line">&quot;Name&quot;: &quot;docker_gwbridge&quot;,</span><br><span class="line">&quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">&quot;IPAM&quot;: &#123;</span><br><span class="line">    &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">    &quot;Options&quot;: null,</span><br><span class="line">    &quot;Config&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Subnet&quot;: &quot;172.18.0.0&#x2F;16&quot;,</span><br><span class="line">            &quot;Gateway&quot;: &quot;172.18.0.1&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">&quot;Options&quot;: &#123;</span><br><span class="line">    &quot;com.docker.network.bridge.enable_icc&quot;: &quot;false&quot;,</span><br><span class="line">    &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;,</span><br><span class="line">    &quot;com.docker.network.bridge.name&quot;: &quot;docker_gwbridge&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure> 我删掉了一些无关紧要的输出以便让大家关注重要的信心:</p>
<ul>
<li>this network uses the driver bridge (the same one used by the standard docker bridge, docker0)</li>
<li><code>it</code> uses subnet 172.18.0.0/16, which is consistent with eth1</li>
<li><code>enable_icc</code> is set to false which means we cannot use this bridge for inter-container communication</li>
<li><code>enable_ip_masquerade</code> is set to true, which means the traffic from the container will be NATed to access external networks (which we saw earlier when we successfully pinged 8.8.8.8)</li>
</ul>
<p>当从在docker0上的另一个也连接在<code>domenet</code>网络的容器去ping容器C0在<code>eth1</code>的IP地址 (172.18.0.2) 时，我们发现，容器间的通信是被禁止的。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker run --rm -it --net demonet debian ping 172.18.0.2</span><br><span class="line">PING 172.18.0.2 (172.18.0.2): 56 data bytes</span><br><span class="line">^C--- 172.18.0.2 ping statistics ---</span><br><span class="line">3 packets transmitted, 0 packets received, 100% packet loss</span><br></pre></td></tr></table></figure></p>
<p>现在，我们又可以更新我们对Docker overlay网络的认知了: <img src="/.com//overlay-net-topo-stage3.png"></p>
<h2 id="what-about-eth0-the-interface-connected-to-the-overlay">What about eth0, the interface connected to the overlay?</h2>
<p><code>eth0</code>对等的网络接口并不在节点docker0的host network namespace. 那么它一定唯一另一个命名空间中。如果我们看看docker0上存在的网络空间: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ sudo ls -1 &#x2F;var&#x2F;run&#x2F;docker&#x2F;netns</span><br><span class="line">e4b8ecb7ae7c</span><br><span class="line">1-13fb802253</span><br></pre></td></tr></table></figure> 我们会发现一个名为<code>1-13fb802253</code>的命令空间。除了<code>1-</code>, 这个命名空间的名字正是我们overlay网络的网络ID的开始部分: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ docker network inspect demonet -f &#123;&#123;.Id&#125;&#125;</span><br><span class="line">13fb802253b6f0a44e17e2b65505490e0c80527e1d78c4f5c74375aff4bf882a</span><br></pre></td></tr></table></figure> 这个命名空间(<code>1-13fb802253</code>)很明显跟我们研究的overlay网络有关。让我们来看看这个命名空间拥有的网络接口： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker0:~$ overns&#x3D;&#x2F;var&#x2F;run&#x2F;docker&#x2F;netns&#x2F;1-13fb802253</span><br><span class="line">docker0:~$ sudo nsenter --net&#x3D;$overns ip -d link show</span><br><span class="line">2: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    link&#x2F;ether 3a:2d:44:c0:0e:aa brd ff:ff:ff:ff:ff:ff promiscuity 0</span><br><span class="line">    bridge</span><br><span class="line">5: vxlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UNKNOWN mode DEFAULT group default</span><br><span class="line">    link&#x2F;ether 4a:23:72:a3:fc:e3 brd ff:ff:ff:ff:ff:ff promiscuity 1</span><br><span class="line">    vxlan id 256 srcport 10240 65535 dstport 4789 proxy l2miss l3miss ageing 300</span><br><span class="line">    bridge_slave</span><br><span class="line">7: veth2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue master br0 state UP mode DEFAULT group default</span><br><span class="line">    link&#x2F;ether 3a:2d:44:c0:0e:aa brd ff:ff:ff:ff:ff:ff promiscuity 1</span><br><span class="line">    veth</span><br><span class="line">    bridge_slave</span><br></pre></td></tr></table></figure></p>
<p>overlay网络所在network namespace包含三个接口(以及lo)：</p>
<ul>
<li>br0: 网桥</li>
<li>veth2: <code>veth</code>类型网络接口，容器C0中网卡<code>eth0</code> 的对等接口，连接在bridge上。</li>
<li>vxlan0: <code>vxlan</code>类型网络接口，并且链接在网桥上。</li>
</ul>
<p>vxlan网络接口明显<code>overlay</code>发挥其魔力的地方。我们将看看其实现细节，不过让我们先更新下拓扑图。 <img src="/.com//overlay-net-topo-stage4.png"></p>
<h1 id="结论">结论</h1>
<p>本段是本系列文章第一部分的总结. 在第二部分, 我们将关注VxLAN: 什么是VxLAN以及Docker是如何使用VXLAN的。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/docker/" rel="tag"># docker</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/09/05/docker-networking/" rel="prev" title="Docker 网络教程">
      <i class="fa fa-chevron-left"></i> Docker 网络教程
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/09/06/docker-overlay-net-deep-tuto-zn2/" rel="next" title="深入了解 Docker overlay 网络机制2">
      深入了解 Docker overlay 网络机制2 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#介绍"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker-overlay-networks"><span class="nav-number">2.</span> <span class="nav-text">Docker Overlay Networks</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#启动-consul-与-docker-服务"><span class="nav-number">3.</span> <span class="nav-text">启动 Consul 与 Docker 服务</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#创建-overlay"><span class="nav-number">4.</span> <span class="nav-text">创建 Overlay</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#overlay-背后的原理"><span class="nav-number">5.</span> <span class="nav-text">Overlay 背后的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#容器的网络配置"><span class="nav-number">5.1.</span> <span class="nav-text">容器的网络配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#what-is-the-container-connected-to"><span class="nav-number">5.2.</span> <span class="nav-text">What is the container connected to?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#what-about-eth0-the-interface-connected-to-the-overlay"><span class="nav-number">5.3.</span> <span class="nav-text">What about eth0, the interface connected to the overlay?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结论"><span class="nav-number">6.</span> <span class="nav-text">结论</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">rennsong</p>
  <div class="site-description" itemprop="description">Personal blog site, to note technique and life related articles</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">69</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hansomesong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hansomesong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rennsong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
